{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Campamento IOI 2023","text":""},{"location":"#temario","title":"Temario","text":""},{"location":"#dia-1","title":"D\u00eda 1","text":"<ul> <li>complejidad</li> <li>b\u00fasqueda binaria</li> <li>stl</li> </ul>"},{"location":"apendice/logaritmos/","title":"Ap\u00e9ndice logaritmo","text":"<p>Recordemos que cada operaci\u00f3n b\u00e1sica tiene su inverso.</p> \\[ a+b \\rightarrow a-b \\] \\[ a \\cdot b \\rightarrow \\frac{a}{b} \\] <p>Tambi\u00e9n la operaci\u00f3n de la potencia \\(a^b\\) tienen su inverso que se le conoce como logaritmo.</p> <p>Si queremos saber el \\(x\\) que soluciona:</p> \\[ a^x = b \\] <p>La notaci\u00f3n que usamos es \\(x = \\log_a(b)\\) que se lee como logaritmo en base \\(a\\) de \\(b\\).</p>"},{"location":"apendice/logaritmos/#nota-importante","title":"Nota importante","text":"<p>Los logaritmos son muy peque\u00f1os para los rangos que se ocupan en programaci\u00f3n competitiva, son casi constantes cuando estamos viendo complejidad. Por lo que es muy conveniente encontrar un logaritmo en la complejidad de una soluci\u00f3n.</p>"},{"location":"apendice/problema_parentesis_balanceados/","title":"Problema par\u00e9ntesis balanceados","text":"<p>Dado que consiste de s\u00f3lo par\u00e9ntesis determine si la expresi\u00f3n est\u00e1 balanceada o no. Se entiende por par\u00e9ntesis balanceado que cada par\u00e9ntesis <code>(</code> tiene su par <code>)</code> correspondiente que lo cierra a si derecha.</p> <p>Por ejemplo <code>(()())</code> es balanceado, pero <code>(()</code> no.</p> <p>La soluci\u00f3n a este problema es con una pilas. Se recorre la expresi\u00f3n y se van guardando los par\u00e9ntesis que se van encontrando. Si se encuentra un par\u00e9ntesis de cierre <code>)</code> se saca el \u00faltimo par\u00e9ntesis de la pila y se verifica que sea de apertura <code>(</code>. Si no es as\u00ed, la expresi\u00f3n no est\u00e1 balanceada. Si la pila est\u00e1 vac\u00eda y se encuentra un par\u00e9ntesis de cierre, la expresi\u00f3n no est\u00e1 balanceada. Al final, si la pila est\u00e1 vac\u00eda, la expresi\u00f3n est\u00e1 balanceada.</p> <pre><code>bool balanceado(string s){\n    stack&lt;char&gt; pila;\n    for(char c : s){\n        if(c == '('){\n            pila.push(c);\n        }else{\n            if(pila.empty()){\n                return false;\n            }\n            char d = pila.top();\n            pila.pop();\n            if(d != '('){\n                return false;\n            }\n        }\n    }\n    return pila.empty();\n}\n</code></pre>"},{"location":"dia-1/busqueda_binaria/","title":"B\u00fasqueda binaria","text":"<p>Generalmente cuando les presentan b\u00fasqueda binaria se muestra con el ejemplo de un arreglo ordenado y encontrar un elemento dado.</p> <p>Dado el siguiente array verifique si est\u00e1 el 8.</p> <p><code>A = [1, 3, 7, 10, 12, 17, 23]</code></p> <p>La soluci\u00f3n naive es recorrer el arreglo y comparar en cada elemento si es igual o no a 8. Esto tiene complejidad \\(\\mathcal{O}(n)\\) para un largo de arreglo \\(n\\).</p> <p>(Animacion inded)</p> <p>Antes cuando el profesor (Javier Marinkovic) iba al colegio (hace muuucho) usaban algo llamado diccionarios, que eran libros con palabras ordenadas alfab\u00e9ticamente. Si por ejemplo quer\u00eda buscar la palabra \"casa\" lo que hacia era ir a la secci\u00f3n de la \"C\" y ve\u00eda si donde estaba abierto el libro estaba la palabra \"casa\". Si no estaba, entonces ve\u00eda que palabra si estaba \"caos\" deb\u00eda ir a una pagina mas a la derecha. Si esta nueva pagina empezaba con la palabra \"cosa\" deb\u00eda ir a una hoja a la izquierda y asi...</p> <p>Regresando al problema original la idea de la b\u00fasqueda binaria es dividir el arreglo en dos partes y ver si el elemento esta en la primera o segunda mitad. Si esta en la primera mitad, entonces la segunda mitad no la consideramos. Si esta en la segunda mitad, entonces la primera mitad no la consideramos. Asi hasta que el elemento este en el arreglo.</p>  <p>Su complejidad es \\(O(\\log_2(n))\\) ya que consta de cuantas veces puedo dividir el arreglo por 2 en el peor de los casos.</p> <p>Pero la b\u00fasqueda binaria es mucho mas general que esto.</p>"},{"location":"dia-1/busqueda_binaria/#forma-mas-generalizada-de-busqueda-binaria","title":"Forma mas generalizada de b\u00fasqueda binaria","text":"<p>La b\u00fasqueda binaria nos ayuda a problemas en donde hay una pregunta mon\u00f3tona en un rango. Ya sea algo como \\(x^2 \\leq n\\) o \\(x^2+3x \\leq n\\).</p> <p>La propiedad mon\u00f3tona es a grandes rasgos, que la pregunta no vuelve a tomar un valor menor que uno anterior (a su izquierda en la recta num\u00e9rica).</p> <p>Veamos para la pregunta \\(P(x) := x^2 \\leq n\\) para los n\u00fameros \\(n = 0, 1, 2, 3, 4, 5, ...\\) con \\(n = 9\\).</p>    \\(x\\) 0 1 2 3 4 5 ...     P(x) V V V V F F ...    <p>\u00bfSer\u00e1 acaso el \\(P(7984)\\) verdadero o falso? O sea, \u00bf\\(7984^2 \\leq 9\\)?</p> <p>Veamos que dado que a su izquierda hay un valor que es falso entonces 7984 tambi\u00e9n lo es. Es m\u00e1s, todos los valores a su derecha ser\u00e1n falsos.</p> <p>Volviendo al problema original del arreglo ordenado, podemos definir nuestra pregunta como \\(P(i) := A[i] \\leq x\\), con \\(x = 8\\). </p> <p>Notemos que la pregunta es mon\u00f3tona:</p>    \\(i\\) 1 3 8 16 19     P(i) V V V F F    <p>Si nosotros encontramos el indice mas grande que cumple esta propiedad, vamos a encontrar en donde deber\u00eda estar el elemento, si es que est\u00e1. El 8 deber\u00eda estar en el \u00faltimo verdadero.</p> <p>De forma m\u00e1s general, supongamos que tenemos nuestra funci\u00f3n mon\u00f3tona y nos paramos en una posici\u00f3n que donde \\(P(x)\\) es verdadera. Algo como lo siguiente:</p> <p>V V V [V] ... V F F F F</p> <p>Sabemos que el \u00faltimo verdadero estar\u00e1 a la derecha, por lo que podemos restringir nuestra b\u00fasqueda a la derecha de la posici\u00f3n en que nos paramos.</p> <p>En cambio si nos paramos en un falso</p> <p>V V V V ... V F F [F] F</p> <p>Sabemos que el \u00faltimo verdadero estar\u00e1 a la izquierda, por lo que podemos restringir nuestra b\u00fasqueda a la izquierda de la posici\u00f3n en que nos paramos.</p>"},{"location":"dia-1/busqueda_binaria/#ejemplo-con-cuadrado-para-cuadrados-perfectos","title":"Ejemplo con cuadrado para cuadrados perfectos","text":"<p>Quiero saber si el 1024 es un cuadrado perfecto. Aplicando b\u00fasqueda binaria podemos armar la pregunta \\(P(X) := x^2 \\leq 1024\\).</p> <p>\u00bfPor qu\u00e9 esta funci\u00f3n ser\u00eda mon\u00f3tona?</p> <p>Primero necesitamos un rango, requerimos que el valor de la izquierda sea verdadero y el l\u00edmite de la derecha sea falso. Para eso podemos tomar \\(x = 1\\) y \\(x = 100\\).</p> <ul> <li>Rango de b\u00fasqueda: \\([1, 100]\\)</li> </ul> <p>Quiero encontrar el ultimo verdadero.</p> <p>Veamos el valor de al medio, \\(x = 50\\). Es \\(50^2 \\leq 1024\\)? No, entonces el ultimo verdadero esta a la izquierda. Acortamos la b\u00fasqueda a la izquierda.</p> <ul> <li>Rango de b\u00fasqueda: \\([1, 50]\\)</li> </ul> <p>Veamos el valor de al medio, \\(x = 25\\). Es \\(25^2 \\leq 1024\\)? Si, entonces el ultimo verdadero esta a la derecha. Acortamos la b\u00fasqueda a la derecha.</p> <ul> <li>Rango de b\u00fasqueda: \\([25, 50]\\)</li> </ul> <p>Veamos el valor de al medio, \\(x = 37\\). Es \\(37^2 \\leq 1024\\)? No, entonces el ultimo verdadero esta a la izquierda. Acortamos la b\u00fasqueda a la izquierda.</p> <ul> <li>Rango de b\u00fasqueda: \\([25, 37]\\)</li> </ul> <p>Veamos el valor de al medio, \\(x = 31\\). Es \\(31^2 \\leq 1024\\)? Si, entonces el ultimo verdadero esta a la derecha. Acortamos la b\u00fasqueda a la derecha.</p> <p>y as\u00ed...</p> <p>Esto terminar\u00e1 cuando nuestro rango se acote a [32, 32], verificamos y tenemos que \\(32^2 = 1024\\) por lo que si es un cuadrado perfecto.</p>"},{"location":"dia-1/busqueda_binaria/#complejidad-de-busqueda-binaria-general","title":"Complejidad de b\u00fasqueda binaria general","text":"<p>\u00bfCu\u00e1ntas veces puedo dividir nuestro rango a la mitad?</p> <p>R: \\(O(\\log_2(n))\\).</p>"},{"location":"dia-1/busqueda_binaria/#ejemplo-real-de-la-hamburguesa","title":"Ejemplo real de la hamburguesa","text":"<p>Resumen:</p> <p>Polycarpo quer\u00eda hacer hamburguesas y tiene la receta de la hamburguesa, que es <code>BBHLB</code>. Ademas sabe cuanto cuesta el pan, la hamburguesa y la lechuga. Se sabe cuantos de estos ingredientes tiene ya en su casa. Dado el dinero que tiene la pregunta es cuanta hamburguesas puede hacer Polycarpo ajustandose a su presupuesto.</p> <p>Definamos la pregunta \\(Q(n) :=\\) \u00bfpuede Polycarpo hacer \\(n\\) hamburguesas?</p> <p>Primero veamos que es mon\u00f3tona. Claramente si puede hacer 50 hamburguesas entonces tambi\u00e9n puede hacer 49. Por otro lado, si no puede hacer 1 trillion de hamburguesas entonces tampoco puede hacer 1 trillion + 1 hamburguesas.</p> <p>Ahora respondamos la pregunta para \\(n\\).</p> <p>Los datos son:</p> <ul> <li>\\(R_B, R_H, R_L\\), la cantidad de ingredientes que necesita para hacer una hamburguesa.</li> <li>\\(\\$B, \\$H, \\$L\\), el costo de cada ingrediente.</li> <li>\\(\\#B, \\#H, \\#L\\), la cantidad de ingredientes que tiene Polycarpo.</li> </ul> <p>El dinero que se gasta en panes para hacer \\(n\\) hamburguesas es \\((n \\cdot R_B - \\#B) \\cdot \\$B\\), siempre y cuando sea positivo, caso contrario seria \\(0\\) ya que polycarpo tiene suficientes panes. Notemoslo como \\(N_B(n) = \\max(0, (n \\cdot R_B - \\#B) \\cdot \\$B)\\). Lo mismo para la lechuga \\(N_L(n)\\) y la hamburguesa \\(N_H(n)\\).</p> <p>El dinero total necesario es \\(N_B(n) + N_L(n) + N_H(n)\\). Si este es menor o igual al dinero que tiene Polycarpo entonces podemos decir que si puede hacer \\(n\\) hamburguesas.</p> <p>La pregunta se reduce a \\(N_B(n) + N_L(n) + N_H(n) \\leq P\\). Podemos ocupar b\u00fasqueda binaria.</p>"},{"location":"dia-1/busqueda_binaria/#complejidad-del-problema","title":"Complejidad del problema","text":"<p>Calcular \\(N_B(n) + N_L(n) + N_H(n) \\leq P\\) es solo hacer operaciones b\u00e1sicas por lo que es \\(\\mathcal{O}(1)\\) y por b\u00fasqueda binaria haremos la verificaci\u00f3n a lo mas \\(\\log_2(n)\\) veces, con \\(n\\) el rango largo del rango de b\u00fasqueda. Para este problema podr\u00edamos haber usado \\([0, P]\\).</p>"},{"location":"dia-1/complejidad/","title":"Complejidad","text":"<p>Es una forma de mesurar la eficiencia de un programa. Daremos una idea intuitiva de complejidad con ejemplos.</p>"},{"location":"dia-1/complejidad/#ejemplo-1","title":"Ejemplo 1","text":"<p>Tenemos el array <code>[1, 3, 4, 2, 5, 7]</code> y queremos saber si esta el \\(5\\) en el array o no.</p>"},{"location":"dia-1/complejidad/#solucion-1","title":"Soluci\u00f3n 1","text":"<p>Recorremos el array y comparamos cada elemento con el \\(5\\).</p> <p>(Animaci\u00f3n de tu eres el 5, si o no)</p> <p>\u00bfCuantas preguntas hay que hacer para saber si esta el \\(5\\) o no? En este caso 5.</p> <p>La idea central es ver el peor de los casos. En este ejemplo el peor de los casos es que el 5 no este en el array por lo que habr\u00eda que hacer la pregunta 6 veces. Para el caso general donde el array es de largo \\(n\\) es \\(n\\).</p> <p>Esto es lo que buscamos en la complejidad, la mayor cantidad de operaciones que tienen que hacerse en el peor de los casos.</p>"},{"location":"dia-1/complejidad/#ejemplo-2","title":"Ejemplo 2","text":"<p>\u00bfCu\u00e1nto se demora el siguiente programa?</p> <pre><code>int suma = 0;\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n        suma += j;\n    }\n}\n</code></pre>"},{"location":"dia-1/complejidad/#solucion-2","title":"Soluci\u00f3n 2","text":"<p>Va a pasar sumarle a la variable <code>suma</code> \\(n^2\\), en notaci\u00f3n asint\u00f3tica esto se escribe como \\(\\mathcal{O}(n^2)\\).</p>"},{"location":"dia-1/complejidad/#ejemplo-3","title":"Ejemplo 3","text":"<p>\u00bfCu\u00e1nto se demora el siguiente programa?</p> <pre><code>int suma = 0;\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n        for (int k = 0; k &lt; n; k++) {\n            suma += k;\n        }\n    }\n}\n</code></pre>"},{"location":"dia-1/complejidad/#solucion-3","title":"Soluci\u00f3n 3","text":"<p>Haciendo el mismo an\u00e1lisis que en el ejemplo 2, la complejidad es \\(\\mathcal{O}(n^3)\\).</p>"},{"location":"dia-1/complejidad/#ideas-generales-de-la-complejidad","title":"Ideas generales de la complejidad","text":"<ul> <li>Hacer \\(k\\) veces una cosa que toma \\(T(n)\\) es \\(\\mathcal{O}(k \\cdot T(n))\\).</li> <li>Hacer un proceso que toma \\(T_1(n)\\) y despu\u00e9s otro que toma \\(T_2(n)\\) es \\(\\mathcal{O}(T_1(n) + T_2(n))\\). Pero si ambos son \\(T(n)\\) entonces el tiempo queda \\(T(2 n)\\) pero como \\(2\\) es una constante se convierte a \\(\\mathcal{O}(n)\\).</li> </ul> <p>Aclaraci\u00f3n importante, las constantes en la notaci\u00f3n asint\u00f3tica se pueden eliminar mientras que las variables se mantienen. Por eso en el ejemplo 2 se elimina el \\(2\\), mientras que en la idea general 1 no se elimina el \\(k\\).</p> <p>El calculo de la complejidad es algo general y puede ser que la constante si var\u00ede el tiempo de ejecuci\u00f3n. Esto es si queremos hilar m\u00e1s fino, pero en general los problemas est\u00e1n dise\u00f1ados para que no importe la constante.</p>"},{"location":"dia-1/complejidad/#ejemplo-mas-dificil","title":"Ejemplo m\u00e1s dif\u00edcil","text":"<pre><code>for i &lt;= n:\n    for i &lt;= j:\n        if A[i] + A[j] == 6:\n            print(\"Si\")\n</code></pre> <p>Con las reglas que hemos visto, la complejidad ser\u00eda de \\(\\mathcal{O}(n^2)\\).</p>"},{"location":"dia-1/complejidad/#como-saber-si-mi-codigo-pasa-dado-que-se-su-complejidad","title":"C\u00f3mo saber si mi c\u00f3digo pasa dado que se su complejidad","text":"<p>Como regla general se considera que un computador hace \\(10^8\\) operaciones por segundo (regla muy general pero sirve). Por lo que puede deducir que si un algoritmo tiene complejidad \\(\\mathcal{O}(n^2)\\) y \\(n = 10^3\\) entonces har\u00e1 \\(10^6\\) operaciones y como \\(10^6 &lt; 10^8\\) entonces el algoritmo se ejecutar\u00e1 en menos de un segundo.</p>    Tama\u00f1o input (\\(n\\)) Posibles complejidades     \\(n \\leq 10\\) \\(\\mathcal{O}(n !), \\mathcal{O}\\left(n^7\\right), \\mathcal{O}\\left(n^6\\right)\\)   \\(n \\leq 20\\) \\(\\mathcal{O}\\left(2^n \\cdot n\\right), \\mathcal{O}\\left(n^5\\right)\\)   \\(n \\leq 80\\) \\(\\mathcal{O}\\left(n^4\\right)\\)   \\(n \\leq 400\\) \\(\\mathcal{O}\\left(n^3\\right)\\)   \\(n \\leq 7500\\) \\(\\mathcal{O}\\left(n^2\\right)\\)   \\(n \\leq 7 \\cdot 10^4\\) \\(\\mathcal{O}(n \\sqrt{n})\\)   \\(n \\leq 5 \\cdot 10^5\\) \\(\\mathcal{O}(n \\log n)\\)   \\(n \\leq 5 \\cdot 10^6\\) \\(\\mathcal{O}(n)\\)   \\(n \\leq 10^{18}\\) \\(\\mathcal{O}\\left(\\log ^2 n\\right), \\mathcal{O}(\\log n), \\mathcal{O}(1)\\)"},{"location":"dia-1/complejidad/#ejemplo-con-insertion-sort","title":"Ejemplo con Insertion Sort","text":"<p>Insertion Sort es un algoritmo de ordenaci\u00f3n cuya idea principal es ir insertando el elemento en la posici\u00f3n correcta recorriendo de izquierda a derecha.</p>"},{"location":"dia-1/complejidad/#codigo-de-insertion-sort","title":"C\u00f3digo de Insertion Sort","text":"<p>El c\u00f3digo de Insertion Sort es el siguiente:</p> <pre><code>for (int i = 1; i &lt; n; i++) {\n    int j = i;\n    while (j &gt; 0 &amp;&amp; A[j] &lt; A[j - 1]) {\n        swap(A[j], A[j - 1]);\n        j--;\n    }\n}\n</code></pre> <p>La complejidad de este algoritmo es \\(\\mathcal{O}(n^2)\\).</p>"},{"location":"dia-1/complejidad/#ejemplo-con-merge-sort","title":"Ejemplo con Merge Sort","text":"<p>La idea de Merge Sort es dividir el array en dos partes y ordenar cada una de ellas por separado. Luego mezclar las dos partes ordenadas.</p> <p>Supongamos que tenemos los arrays <code>A = [1, 3, 7, 10]</code> y <code>B = [2, 5, 9]</code>. Dado que ambos est\u00e1n ordenados \u00bfC\u00f3mo ordenar\u00edas un array combinado de <code>A</code> con <code>B</code>?</p> <p>Podemos hacerlo con dos punteros, quedando: </p> <p><code>AB = [1, 2, 3, 5, 7, 9, 10]</code></p> <p>\u00bfCu\u00e1l es la complejidad de hacer esto? Es el largo de <code>A</code> m\u00e1s el largo de <code>B</code>. Supongamos que el largo de <code>A</code> es \\(n\\) y el de <code>B</code>, \\(m\\) entonces la complejidad ser\u00eda \\(\\mathcal{O}(n+m)\\).</p> <p>Ahora que sabemos c\u00f3mo juntar dos arrays ordenados podemos ocupar esto para ordenar un arreglo desordenado completamente.</p> <p>Vamos dividir a la mitad arreglo que deseamos ordenar. Luego cada mitad le aplicamos un algoritmo misterioso que los ordenar, y despu\u00e9s de que cada partici\u00f3n est\u00e1 ordenada podemos ocupar el algoritmo que ya conocemos para regresar el array completo ordenado.</p> <p>\u00bfCu\u00e1l es ese algoritmo misterioso? pues, el mismo (recursion).</p>  <p>En la base de esto estar\u00e1 ordenar el array de un solo elemento, como ya est\u00e1 ordenado (es solo un elemento) podemos retornar este arreglo unitario.</p> <p>Ahora veamos cual es su complejidad. Primero recordemos que la complejidad de unir dos arrays ordenados en otro ordenado (merge) es de \\(\\mathcal{O}(n)\\) con \\(n\\) el largo del array final. Pero cada nivel del merge toma \\(\\mathcal{O}(n)\\). \u00bfCu\u00e1ntos niveles van a haber en total? como en cada paso dividimos el arreglo en 2 va a ser hasta que queden arreglos de tama\u00f1o 1. Y esta cantidad sera aproximadamente \\(\\log_2(n)\\).</p> <p>Asi, el algoritmo de Merge Sort tiene complejidad \\(\\mathcal{O}(n \\cdot \\log_2(n))\\).</p> <p>Si no sabes que es un logaritmo ver ap\u00e9ndice.</p>"},{"location":"dia-1/complejidad/#codigo-de-merge-sort","title":"C\u00f3digo de Merge Sort","text":"<p>EL c\u00f3digo en <code>C++</code> ser\u00eda el siguiente:</p> <pre><code>void mergeSort(vector&lt;int&gt; &amp;A) {\n    if (A.size() == 1) {\n        return;\n    } else {\n        int mid = A.size() / 2;\n        vector&lt;int&gt; left(A.begin(), A.begin() + mid);\n        vector&lt;int&gt; right(A.begin() + mid, A.end());\n        mergeSort(left);\n        mergeSort(right);\n        merge(left, right, A);\n    }\n}\n\nvoid merge(vector&lt;int&gt; &amp;left, vector&lt;int&gt; &amp;right, vector&lt;int&gt; &amp;A) {\n    int i = 0, j = 0, k = 0;\n    while (i &lt; left.size() &amp;&amp; j &lt; right.size()) {\n        if (left[i] &lt; right[j]) {\n            A[k] = left[i];\n            i++;\n        } else {\n            A[k] = right[j];\n            j++;\n        }\n        k++;\n    }\n    while (i &lt; left.size()) {\n        A[k] = left[i];\n        i++;\n        k++;\n    }\n    while (j &lt; right.size()) {\n        A[k] = right[j];\n        j++;\n        k++;\n    }\n}\n</code></pre>"},{"location":"dia-1/complejidad/#las-operaciones-toman-tiempo-constante","title":"Las operaciones toman tiempo constante","text":"<p>Vamos a asumir que las operaciones de \\(c++\\) toman tiempo \\(\\mathcal{O}(1)\\), esto si nos ponemos muy detallistas no es tan cierto. Para los rangos de tipos de datos que trabajamos los procesadores trabajan muy bien con sus operaciones.</p>"},{"location":"dia-1/stl/","title":"Librer\u00eda Est\u00e1ndar de <code>C++</code> (STL)","text":"<p>Cuando ocupan vectores en <code>C++</code> est\u00e1n usando la librer\u00eda est\u00e1ndar (STL). Quiz\u00e1s para ocupar vectores a\u00f1ades la l\u00ednea <code>#include &lt;vector&gt;</code> al principio de tu c\u00f3digo. Podemos importar todas las herramientas que trae la librer\u00eda est\u00e1ndar de <code>C++</code> (vectores incluidos) con <code>#include &lt;bits/stdc++.h&gt;</code>.</p> <p>Lo que nos interesa es aprovechar las estructuras que trae consigo la STL.</p>"},{"location":"dia-1/stl/#set","title":"Set","text":"<p>Set, conjunto en ingl\u00e9s, es una estructura que viene en la STL. Set es un conjunto en el cual a\u00f1adir elementos y preguntar si un elemento est\u00e1 en el conjunto toma tiempo \\(\\mathcal{O}(\\log(N))\\).</p> <pre><code>set&lt;int&gt; cartas;  // crea un set vacio, en vez de int\n                  // puedes poner otros tipos de datos\n                  // ver importante 2\ncartas.insert(x); // inserta el elemento x\ncartas.count(x);  // pregunta si x esta en el set\n                  // regresa 0 si no esta y 1 si esta\ncartas.erase(x);  // borra el elemento x\n</code></pre> <p>Importante 1: el set no permite elementos repetidos. Para tener elementos repetidos ocupas un <code>multiset</code>. Sin embargo (Marinkvich) no lo recomienda, en vez de eso puedes ocupar un <code>map</code> que es otra estructura que viene en la STL.</p> <p>Importante 2: S\u00f3lo se permiten sets de valores comparables. El tipo de dato con el cual se crea el set debe tener un sentido de orden. Se pueden hacer sets de <code>string</code> o <code>vectores</code>.</p> <p>Importante 3: No podemos acceder a una posici\u00f3n del set por indice.</p>"},{"location":"dia-1/stl/#problema-de-cartas-de-pony","title":"Problema de Cartas de Pony","text":"<p>Resumen: Javier tiene \\(N\\) cartas de un juego de cartas que pueden tener el valor de \\(1\\) al \\(10^9\\). T\u00fa tarea es responser una cantidad \\(M\\) (de a lo m\u00e1s \\(10^5\\)) preguntas, responder si una carta est\u00e1 en el mazo o no.</p>"},{"location":"dia-1/stl/#solucion-con-busqueda-binaria","title":"Soluci\u00f3n con b\u00fasqueda binaria","text":"<p>Se podia resolver metiendo todas las cartas en un arreglo o vector, ordenando el arreglo y luego buscar cada carta con una b\u00fasqueda binaria. Esto es \\(\\mathcal{O}(N\\log(N))\\).</p>"},{"location":"dia-1/stl/#solucion-con-set","title":"Soluci\u00f3n con set","text":"<p>Otra soluci\u00f3n es ocupar un <code>set</code>. Guardamos los valores de las cartas en un set y luego preguntamos si cada carta est\u00e1 en el set.</p> <pre><code>set&lt;int&gt; cartas;\nfor (int i = 0; i &lt; N; i++) {\n  int x;\n  cin &gt;&gt; x;\n  cartas.insert(x);\n}\n\nint M;\ncin &gt;&gt; M;\nfor (int i = 0; i &lt; M; i++) {\n  int x;\n  cin &gt;&gt; x;\n  if (cartas.count(x)) {\n    cout &lt;&lt; \"SI\" &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; \"NO\" &lt;&lt; endl;\n  }\n}\n</code></pre>"},{"location":"dia-1/stl/#map","title":"Map","text":"<p>El <code>map</code> es el hijo del <code>vector</code> y el <code>set</code>. En un vector tenemos hartos valores y podemos acceder a ellos por su indice. En un set tenemos hartos valores y podemos preguntar si un valor est\u00e1 o no en el set.</p> <p>En el mapa podemos tener hartos valores, podemos preguntar si un valor esta en el mapa y podemos acceder a ellos por su llave. Esta llave, a diferencia del vector que debe ser desde el \\(0\\), puede ser cualquier valor (hasheable) que queramos.</p> <pre><code>map&lt;int, int&gt; mapa; // crea un mapa vacio\n                    // en vez de int, int puedes poner\n                    // cualquier tipo de dato\n\nmapa[x] = y;        // asigna el valor y a la llave x\nmapa[x];            // regresa el valor asociado a la llave x\nmapa.count(x);      // pregunta si la llave x esta en el mapa\n                    // regresa 0 si no esta y 1 si esta\nmapa.erase(x);      // borra la llave x y su valor asociado\n</code></pre>"},{"location":"dia-1/stl/#como-contar-cosas-con-un-mapa","title":"C\u00f3mo contar cosas con un mapa","text":"<p>Supongamos que tenemos un arreglo de \\(n\\) elementos y queremos saber cuantas veces est\u00e1 cada elemento. Podemos tener un mapa <code>M</code> que el valor de <code>M[x]</code> sea cuantas veces est\u00e1 el elemento <code>x</code>.</p> <p><code>M.count(x)</code> responde <code>0</code> no existe la llave <code>x</code> y <code>1</code> si existe la llave <code>x</code>.</p> <p>Todas sus operaciones son \\(O(\\log(n))\\).</p>"},{"location":"dia-1/stl/#las-posibilidades-estan-en-tu-imaginacion","title":"Las posibilidades est\u00e1n en tu imaginaci\u00f3n","text":"<p>Podemos tener arreglos que accedamos por strings y que regresa un vector de enteros.</p>"},{"location":"dia-1/stl/#problema-del-pony-2","title":"Problema del pony 2","text":"<p>Resumen: Javier ahora quiere intercambiar cartas con Mart\u00edn. Te piden verificar si una cierta cantidad intercambio de cartas son posible. Para ello, tienes que responder si es posible intercambiar la carta \\(x\\) por la carta \\(y\\). Se puede intercambiar siempre y cuando Javier disponga de la carta \\(x\\). Te dan la lista de cartas que tiene Javier que pueden ser n\u00fameros del \\(1\\) al \\(10^9\\).</p>"},{"location":"dia-1/stl/#solucion-con-map","title":"Soluci\u00f3n con map","text":"<p>Podemos ocupar un mapa que cuenta las veces que se tiene cada carta.</p> <pre><code>map&lt;int, int&gt; cartas;\nfor (int i = 0; i &lt; N; i++) {\n  int x;\n  cin &gt;&gt; x;\n  cartas[x]++;\n}\n\nint M;\ncin &gt;&gt; M;\nfor (int i = 0; i &lt; M; i++) {\n  int x, y;\n  cin &gt;&gt; x &gt;&gt; y;\n  if (cartas.count(x) &amp;&amp; cartas[x] &gt; 0) {\n    cout &lt;&lt; \"SI\" &lt;&lt; endl;\n    cartas[x]--;\n    cartas[y]++;\n  } else {\n    cout &lt;&lt; \"NO\" &lt;&lt; endl;\n  }\n}\n</code></pre>"},{"location":"dia-1/stl/#queue","title":"Queue","text":"<p>Fila en ingl\u00e9s. Nos permite simular una fila. No conviene usar un <code>vector</code> ya que este no nos permite sacar elementos del principio.</p> <pre><code>queue&lt;int&gt; fila; // crea una fila vacia\nfila.push(x);    // a\u00f1ade un elemento al final\nfila.pop();      // elimina el elemento del principio\nfila.front();    // regresa el valor elemento del principio\nfila.empty();    // pregunta si la fila esta vacia\n                 // regresa false si no esta vacia y true si esta vacia\n</code></pre>"},{"location":"dia-1/stl/#problema-de-registro-ioi","title":"Problema de registro IOI","text":"<p>Resumen: Hay una fila que tiene que ser atendida. Existen dos eventos, la llegada de una persona y que Nacho atienda la inscripci\u00f3n. En el primer caso est\u00e1 persona se a\u00f1ade a la cola. En el segundo si no hay nadie en la cola se imprime un <code>1</code> y si hay alguien se imprime el n\u00famero de la persona que est\u00e1 siendo atendida y se elimina de la cola.</p>"},{"location":"dia-1/stl/#solucion-con-queue","title":"Soluci\u00f3n con queue","text":"<p>Resuelve este problema de manera directa usando un <code>queue</code>.</p> <pre><code>queue&lt;int&gt; fila;\nint N;\ncin &gt;&gt; N;\nfor (int i = 0; i &lt; N; i++) {\n  string s;\n  int x;\n  cin &gt;&gt; s &gt;&gt; x;\n  if (s == \"A\") {\n    fila.push(x);\n  } else {\n    if (fila.empty()) {\n      cout &lt;&lt; 1 &lt;&lt; endl;\n    } else {\n      cout &lt;&lt; fila.front() &lt;&lt; endl;\n      fila.pop();\n    }\n  }\n}\n</code></pre>"},{"location":"dia-1/stl/#stack","title":"Stack","text":"<p>Pila en ingles. Nos permite simular una pila. Donde lo que sacamos es el primer elemento y a\u00f1adimos elementos es al inicio de la pila. Como una pila de platos.</p> <pre><code>stack&lt;int&gt; pila; // crea una pila vacia\npila.push(x);    // a\u00f1ade un elemento al principio\npila.pop();      // elimina el elemento del principio\npila.top();      // regresa el valor elemento del principio\npila.empty();    // pregunta si la pila esta vacia\n                 // regresa false si no esta vacia y true si esta vacia\n</code></pre>"},{"location":"dia-1/stl/#deque","title":"Deque","text":"<p>Es una cola doble. Nos permite sacar y quitar elementos del principio y del final.</p> <pre><code>deque&lt;int&gt; cola; // crea una cola vacia\ncola.push_back(x);    // a\u00f1ade un elemento al final\ncola.push_front(x);   // a\u00f1ade un elemento al principio\ncola.pop_back();      // elimina el elemento del final\ncola.pop_front();     // elimina el elemento del principio\ncola.back();          // regresa el valor elemento del final\ncola.front();         // regresa el valor elemento del principio\ncola.empty();         // pregunta si la cola esta vacia\n                      // regresa false si no esta vacia y true si esta vacia\n</code></pre> <p>Todo lo hace en \\(\\mathcal{O}(1)\\).</p> <p>Nota: el <code>deque</code> pese a ser muy \u00fatil, muchas veces basta con s\u00f3lo ocupar una cola o una pila. Adem\u00e1s que la <code>deque</code> es menos eficiente.</p>"},{"location":"dia-1/stl/#priority-queue","title":"Priority Queue","text":"<p>Es una cola de prioridad. Nos permite tener una cola la cual el primer elemento es siempre el valor mas grande. Por defecto esta ordenada de menor a mayor seg\u00fan el comparador por defecto.</p> <pre><code>priority_queue&lt;int&gt; cola; // crea una cola vacia\ncola.push(x);    // a\u00f1ade un elemento\ncola.pop();      // elimina el elemento del principio\ncola.top();      // regresa el valor elemento del principio\ncola.empty();    // pregunta si la cola esta vacia\n                 // regresa false si no esta vacia y true si esta vacia\n</code></pre> <p>Los costos de hacer <code>push</code>, <code>pop</code> y <code>top</code> son \\(\\mathcal{O}(\\log(n))\\). Mientras que <code>top</code> es \\(\\mathcal{O}(1)\\).</p>"},{"location":"dia-1/stl/#comparar-de-menor-a-mayor","title":"Comparar de menor a mayor","text":"<p>Podemos ocupar un comparador personalizado para que la cola de prioridad ordene de mayor a menor.</p> <pre><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; cola;\n</code></pre> <p>El <code>int</code> se puede cambiar por la clase/tipo de dato de la cola, ejemplo <code>greater&lt;pair&lt;int, int&gt;&gt;</code>.</p>"},{"location":"dia-1/stl/#algoritmos-ya-implementados-en-la-stl","title":"Algoritmos ya implementados en la STL","text":"<ul> <li><code>sort</code>: ordena un vector de menor a mayor. El costo es \\(\\mathcal{O}(n \\log(n))\\).</li> </ul> <pre><code>sort(v.begin(), v.end()); // ordena el vector v\n</code></pre> <ul> <li><code>lower_bound</code>: le pasas un vector y un valor y el iterador que apunta al primer elemento mayor o igual al valor. Si no existe retorna el iterador al final del vector. Hace una b\u00fasqueda binaria.</li> </ul> <pre><code>auto pos = lower_bound(v.begin(), v.end(), x) - v.begin();\nif (pos == v.end()) {\n  // no existe\n} else {\n  if (*v == x) {\n    // x esta en v\n  } else {\n    // hay un elemento mayor a x\n  }\n}\n</code></pre> <ul> <li><code>upper_bound</code>: lo mismo que <code>lower_bound</code> pero te regresa el primer elemento mayor al valor. Si no existe retorna el iterador al final del vector. Hace una b\u00fasqueda binaria.</li> </ul> <pre><code>auto pos = upper_bound(v.begin(), v.end(), x) - v.begin();\n</code></pre> <ul> <li><code>find</code>: le pasas un vector y un valor y regresa el iterador al primer elemento igual al valor. Si no existe retorna el iterador al final del vector. Hace una b\u00fasqueda lineal.</li> </ul> <pre><code>auto pos = find(v.begin(), v.end(), x) - v.begin();\nif (pos == v.end()) {\n  // no existe\n} else {\n  // existe\n}\n</code></pre>"},{"location":"dia-1/stl/#referencias-de-la-stl","title":"Referencias de la STL","text":"<ul> <li>C++ Reference</li> <li>Cpp Reference</li> </ul>"},{"location":"dia-2/resolucion_contest_1/","title":"Resoluci\u00f3n problemas del contest 1","text":"<p>Las explicaciones de los problemas presentados son los conversados en este d\u00eda y en el orden en que se mostraron. No est\u00e1n todos los problemas del contest.</p>"},{"location":"dia-2/resolucion_contest_1/#c-valeriy-and-deque","title":"C - Valeriy and Deque","text":"<p>Idea central: primero se debe precomputar hasta el movimiento \\(10^5\\), y luego notar que las siguientes operaciones van a formar un ciclo de largo \\(n-1\\) ya que todo esta ordenado.</p> <p>Si la consulta es una operaci\u00f3n menor que \\(10^5\\) se responde con el resultado guardado, caso contrario podemos ocupar la f\u00f3rmula <code>deque[(q-1)%(n-1)]</code>.</p> <p>Al principio podr\u00eda haberse ocurrido hacer una deque y simular todo, pero esto no entra en tiempo debido a que se debe simular hasta el movimiento \\(10^17+5\\) que no entra en el tiempo.</p>"},{"location":"dia-2/resolucion_contest_1/#b-deadline","title":"B - Deadline","text":"<p>Para este problema hay que notar que va a haber un rango de \\(x\\) en donde hacer usar un d\u00eda m\u00e1s para optimizar su programa baja su tiempo de trabajo. Es decir</p> \\[ x + \\left \\lceil \\frac{d}{x+1} \\right \\rceil \\leq (x + 1) + \\left \\lceil \\frac{d}{x+2} \\right \\rceil \\] <p>pero va a llegar un momento en el que usar un d\u00eda m\u00e1s, no va a baja el tiempo de trabajo, sino que lo aumenta. Es decir</p> \\[ x + \\left \\lceil \\frac{d}{x+1} \\right \\rceil &gt; (x + 1) + \\left \\lceil \\frac{d}{x+2} \\right \\rceil \\] <p>Ese punto de quiebre, en el que le deja de convenir pasarse un d\u00eda m\u00e1s optimizando su trabajo va a coincidir con el m\u00ednimo de la funci\u00f3n \\(f(x) = x + \\ceil{\\frac{d}{x+1}}\\). Por lo que podemos ocupar una b\u00fasqueda binaria para encontrar ese punto.</p> <pre><code>int f(int x) {\n    return x + (d+x)/(x+1);\n}\n\nbool p(int x) {\n    return f(x+1) &gt; f(x);\n}\n\nint binary(int n) {\n    int left = 0;\n    int right = n;\n    while(left &lt; right) {\n        int mid = (left + right) / 2;\n        if(p(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n</code></pre> <p>Notemos que en vez de usar la funci\u00f3n <code>ceil</code> de <code>c++</code> podemos ocupar el viejo truco de sumarle el denominador al numerador y dividir entre el denominador m\u00e1s uno. Es decir</p> \\[ \\left \\lceil \\frac{a}{b} \\right \\rceil = \\frac{a+b-1}{b} \\] <p>Es mejor ocupar esta f\u00f3rmula ya que con <code>ceil</code> corremos el riesgo de presentar un error de redondeo.</p>"},{"location":"dia-2/resolucion_contest_1/#d-guess-a-number","title":"D - Guess a number!","text":"<p>La idea de este problema es usar el inside de b\u00fasqueda binaria. Definimos una variable left y right, y vamos actualizando el rango a medida que nos van dando las respuestas. Si en alg\u00fan punto el rango pierde coherencia (left &gt; right) entonces el n\u00famero no existe.</p>"},{"location":"dia-2/resolucion_contest_1/#e-alternating-current","title":"E - Alternating Current","text":"<p>Mirando el cable desde el inicio, no se puede desenredar si en la secuencia en alg\u00fan momento hay un <code>+</code> que no se pare\u00f3 con un <code>-</code>. Es decir, cables del estilo <code>-++</code>, ac\u00e1 el primer <code>+</code> no se puede desenredar. Por lo que si en alg\u00fan momento hay un <code>+</code> que no se pare\u00f3 con un <code>-</code> entonces la respuesta es <code>No</code>.</p> <p>Para este problema se puede usar una pila para simular el proceso. Si el caracter actual es igual al \u00faltimo caracter de la pila, entonces se saca el \u00faltimo caracter de la pila, caso contrario se agrega el caracter actual a la pila. Es b\u00e1sicamente el problema de los par\u00e9ntesis balanceados.</p>"},{"location":"dia-2/resolucion_contest_1/#f-winner","title":"F - Winner","text":"<p>Para este problema se puede usar un map para guardar los puntajes de cada jugador. Mientras se van obteniendo los puntajes parciales, agregan a un vector el nombre del jugador unido al puntaje parcial que ten\u00eda en aquel momento.</p> <p>Luego se revisa cu\u00e1ntos jugadores obtuvieron el mayor puntaje. Si no hay empate entonces se imprime el nombre del jugador que tiene el puntaje mayor. Si hay empate entonces se recorre la cola hasta obtener el primer jugador cuyo puntaje parcial fue al menos igual al mayor puntaje y este obtuvo un puntaje final ganador, y se imprime su nombre.</p>"}]}
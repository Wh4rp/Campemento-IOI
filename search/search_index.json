{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"apendice/logaritmos/","title":"Ap\u00e9ndice logaritmo","text":"<p>Recordemos que cada operaci\u00f3n b\u00e1sica tiene su inverso.</p> \\[ a+b \\rightarrow a-b \\] \\[ a \\cdot b \\rightarrow \\frac{a}{b} \\] <p>Tambi\u00e9n la operaci\u00f3n de la potencia \\(a^b\\) tienen su inverso que se le conoce como logaritmo.</p> <p>Si queremos saber el \\(x\\) que soluciona:</p> \\[ a^x = b \\] <p>La notaci\u00f3n que usamos es \\(x = \\log_a(b)\\) que se lee como logaritmo en base \\(a\\) de \\(b\\).</p>"},{"location":"apendice/logaritmos/#nota-importante","title":"Nota importante","text":"<p>Los logaritmos son muy peque\u00f1os para los rangos que se ocupan en programaci\u00f3n competitiva, son casi constantes cuando estamos viendo complejidad. Por lo que es muy conveniente encontrar un logaritmo en la complejidad de una soluci\u00f3n.</p>"},{"location":"dia-1/busqueda_binaria/","title":"B\u00fasqueda binaria","text":"<p>Generalmente cuando les presentan b\u00fasqueda binaria se muestra con el ejemplo de un arreglo ordenado y encontrar un elemento dado.</p> <p>Dado el siguiente array verifique si est\u00e1 el 8.</p> <p><code>A = [1, 3, 7, 10, 12, 17, 23]</code></p> <p>La soluci\u00f3n naive es recorrer el arreglo y comparar en cada elemento si es igual o no a 8. Esto tiene complejidad \\(\\mathcal{O}(n)\\) para un largo de arreglo \\(n\\).</p> <p>(Animacion inded)</p> <p>Antes cuando el profesor (Javier Marinkovic) iba al colegio (hace muuucho) usaban algo llamado diccionarios, que eran libros con palabras ordenadas alfab\u00e9ticamente. Si por ejemplo quer\u00eda buscar la palabra \"casa\" lo que hacia era ir a la secci\u00f3n de la \"C\" y ve\u00eda si donde estaba abierto el libro estaba la palabra \"casa\". Si no estaba, entonces ve\u00eda que palabra si estaba \"caos\" deb\u00eda ir a una pagina mas a la derecha. Si esta nueva pagina empezaba con la palabra \"cosa\" deb\u00eda ir a una hoja a la izquierda y asi...</p> <p>Regresando al problema original la idea de la b\u00fasqueda binaria es dividir el arreglo en dos partes y ver si el elemento esta en la primera o segunda mitad. Si esta en la primera mitad, entonces la segunda mitad no la consideramos. Si esta en la segunda mitad, entonces la primera mitad no la consideramos. Asi hasta que el elemento este en el arreglo.</p>  <p>Su complejidad es \\(O(\\log_2(n))\\) ya que consta de cuantas veces puedo dividir el arreglo por 2 en el peor de los casos.</p> <p>Pero la b\u00fasqueda binaria es mucho mas general que esto.</p>"},{"location":"dia-1/busqueda_binaria/#forma-mas-generalizada-de-busqueda-binaria","title":"Forma mas generalizada de b\u00fasqueda binaria","text":"<p>La b\u00fasqueda binaria nos ayuda a problemas en donde hay una pregunta mon\u00f3tona en un rango. Ya sea algo como \\(x^2 \\leq n\\) o \\(x^2+3x \\leq n\\).</p> <p>La propiedad mon\u00f3tona es a grandes rasgos, que la pregunta no vuelve a tomar un valor menor que uno anterior (a su izquierda en la recta num\u00e9rica).</p> <p>Veamos para la pregunta \\(P(x) := x^2 \\leq n\\) para los n\u00fameros \\(n = 0, 1, 2, 3, 4, 5, ...\\) con \\(n = 9\\).</p>    \\(x\\) 0 1 2 3 4 5 ...     P(x) V V V V F F ...    <p>\u00bfSer\u00e1 acaso el \\(P(7984)\\) verdadero o falso? O sea, \u00bf\\(7984^2 \\leq 9\\)?</p> <p>Veamos que dado que a su izquierda hay un valor que es falso entonces 7984 tambi\u00e9n lo es. Es m\u00e1s, todos los valores a su derecha ser\u00e1n falsos.</p> <p>Volviendo al problema original del arreglo ordenado, podemos definir nuestra pregunta como \\(P(i) := A[i] \\leq x\\), con \\(x = 8\\). </p> <p>Notemos que la pregunta es mon\u00f3tona:</p>    \\(i\\) 1 3 8 16 19     P(i) V V V F F    <p>Si nosotros encontramos el indice mas grande que cumple esta propiedad, vamos a encontrar en donde deber\u00eda estar el elemento, si es que est\u00e1. El 8 deber\u00eda estar en el \u00faltimo verdadero.</p> <p>De forma m\u00e1s general, supongamos que tenemos nuestra funci\u00f3n mon\u00f3tona y nos paramos en una posici\u00f3n que donde \\(P(x)\\) es verdadera. Algo como lo siguiente:</p> <p>V V V [V] ... V F F F F</p> <p>Sabemos que el \u00faltimo verdadero estar\u00e1 a la derecha, por lo que podemos restringir nuestra b\u00fasqueda a la derecha de la posici\u00f3n en que nos paramos.</p> <p>En cambio si nos paramos en un falso</p> <p>V V V V ... V F F [F] F</p> <p>Sabemos que el \u00faltimo verdadero estar\u00e1 a la izquierda, por lo que podemos restringir nuestra b\u00fasqueda a la izquierda de la posici\u00f3n en que nos paramos.</p>"},{"location":"dia-1/busqueda_binaria/#ejemplo-con-cuadrado-para-cuadrados-perfectos","title":"Ejemplo con cuadrado para cuadrados perfectos","text":"<p>Quiero saber si el 1024 es un cuadrado perfecto. Aplicando b\u00fasqueda binaria podemos armar la pregunta \\(P(X) := x^2 \\leq 1024\\).</p> <p>\u00bfPor qu\u00e9 esta funci\u00f3n ser\u00eda mon\u00f3tona?</p> <p>Primero necesitamos un rango, requerimos que el valor de la izquierda sea verdadero y el l\u00edmite de la derecha sea falso. Para eso podemos tomar \\(x = 1\\) y \\(x = 100\\).</p> <ul> <li>Rango de b\u00fasqueda: \\([1, 100]\\)</li> </ul> <p>Quiero encontrar el ultimo verdadero.</p> <p>Veamos el valor de al medio, \\(x = 50\\). Es \\(50^2 \\leq 1024\\)? No, entonces el ultimo verdadero esta a la izquierda. Acortamos la b\u00fasqueda a la izquierda.</p> <ul> <li>Rango de b\u00fasqueda: \\([1, 50]\\)</li> </ul> <p>Veamos el valor de al medio, \\(x = 25\\). Es \\(25^2 \\leq 1024\\)? Si, entonces el ultimo verdadero esta a la derecha. Acortamos la b\u00fasqueda a la derecha.</p> <ul> <li>Rango de b\u00fasqueda: \\([25, 50]\\)</li> </ul> <p>Veamos el valor de al medio, \\(x = 37\\). Es \\(37^2 \\leq 1024\\)? No, entonces el ultimo verdadero esta a la izquierda. Acortamos la b\u00fasqueda a la izquierda.</p> <ul> <li>Rango de b\u00fasqueda: \\([25, 37]\\)</li> </ul> <p>Veamos el valor de al medio, \\(x = 31\\). Es \\(31^2 \\leq 1024\\)? Si, entonces el ultimo verdadero esta a la derecha. Acortamos la b\u00fasqueda a la derecha.</p> <p>y as\u00ed...</p> <p>Esto terminar\u00e1 cuando nuestro rango se acote a [32, 32], verificamos y tenemos que \\(32^2 = 1024\\) por lo que si es un cuadrado perfecto.</p>"},{"location":"dia-1/busqueda_binaria/#complejidad-de-busqueda-binaria-general","title":"Complejidad de b\u00fasqueda binaria general","text":"<p>\u00bfCu\u00e1ntas veces puedo dividir nuestro rango a la mitad?</p> <p>R: \\(O(\\log_2(n))\\).</p>"},{"location":"dia-1/busqueda_binaria/#ejemplo-real-de-la-hamburguesa","title":"Ejemplo real de la hamburguesa","text":"<p>Resumen:</p> <p>Polycarpo quer\u00eda hacer hamburguesas y tiene la receta de la hamburguesa, que es <code>BBHLB</code>. Ademas sabe cuanto cuesta el pan, la hamburguesa y la lechuga. Se sabe cuantos de estos ingredientes tiene ya en su casa. Dado el dinero que tiene la pregunta es cuanta hamburguesas puede hacer Polycarpo ajustandose a su presupuesto.</p> <p>Definamos la pregunta \\(Q(n) :=\\) \u00bfpuede Polycarpo hacer \\(n\\) hamburguesas?</p> <p>Primero veamos que es mon\u00f3tona. Claramente si puede hacer 50 hamburguesas entonces tambi\u00e9n puede hacer 49. Por otro lado, si no puede hacer 1 trillion de hamburguesas entonces tampoco puede hacer 1 trillion + 1 hamburguesas.</p> <p>Ahora respondamos la pregunta para \\(n\\).</p> <p>Los datos son:</p> <ul> <li>\\(R_B, R_H, R_L\\), la cantidad de ingredientes que necesita para hacer una hamburguesa.</li> <li>\\(\\$B, \\$H, \\$L\\), el costo de cada ingrediente.</li> <li>\\(\\#B, \\#H, \\#L\\), la cantidad de ingredientes que tiene Polycarpo.</li> </ul> <p>El dinero que se gasta en panes para hacer \\(n\\) hamburguesas es \\((n \\cdot R_B - \\#B) \\cdot \\$B\\), siempre y cuando sea positivo, caso contrario seria \\(0\\) ya que polycarpo tiene suficientes panes. Notemoslo como \\(N_B(n) = \\max(0, (n \\cdot R_B - \\#B) \\cdot \\$B)\\). Lo mismo para la lechuga \\(N_L(n)\\) y la hamburguesa \\(N_H(n)\\).</p> <p>El dinero total necesario es \\(N_B(n) + N_L(n) + N_H(n)\\). Si este es menor o igual al dinero que tiene Polycarpo entonces podemos decir que si puede hacer \\(n\\) hamburguesas.</p> <p>La pregunta se reduce a \\(N_B(n) + N_L(n) + N_H(n) \\leq P\\). Podemos ocupar b\u00fasqueda binaria.</p>"},{"location":"dia-1/busqueda_binaria/#complejidad-del-problema","title":"Complejidad del problema","text":"<p>Calcular \\(N_B(n) + N_L(n) + N_H(n) \\leq P\\) es solo hacer operaciones b\u00e1sicas por lo que es \\(\\mathcal{O}(1)\\) y por b\u00fasqueda binaria haremos la verificaci\u00f3n a lo mas \\(\\log_2(n)\\) veces, con \\(n\\) el rango largo del rango de b\u00fasqueda. Para este problema podr\u00edamos haber usado \\([0, P]\\).</p>"},{"location":"dia-1/complejidad/","title":"Complejidad","text":"<p>Es una forma de mesurar la eficiencia de un programa. Daremos una idea intuitiva de complejidad con ejemplos.</p>"},{"location":"dia-1/complejidad/#ejemplo-1","title":"Ejemplo 1","text":"<p>Tenemos el array <code>[1, 3, 4, 2, 5, 7]</code> y queremos saber si esta el \\(5\\) en el array o no.</p>"},{"location":"dia-1/complejidad/#solucion-1","title":"Soluci\u00f3n 1","text":"<p>Recorremos el array y comparamos cada elemento con el \\(5\\).</p> <p>(Animaci\u00f3n de tu eres el 5, si o no)</p> <p>\u00bfCuantas preguntas hay que hacer para saber si esta el \\(5\\) o no? En este caso 5.</p> <p>La idea central es ver el peor de los casos. En este ejemplo el peor de los casos es que el 5 no este en el array por lo que habr\u00eda que hacer la pregunta 6 veces. Para el caso general donde el array es de largo \\(n\\) es \\(n\\).</p> <p>Esto es lo que buscamos en la complejidad, la mayor cantidad de operaciones que tienen que hacerse en el peor de los casos.</p>"},{"location":"dia-1/complejidad/#ejemplo-2","title":"Ejemplo 2","text":"<p>\u00bfCu\u00e1nto se demora el siguiente programa?</p> <pre><code>int suma = 0;\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n        suma += j;\n    }\n}\n</code></pre>"},{"location":"dia-1/complejidad/#solucion-2","title":"Soluci\u00f3n 2","text":"<p>Va a pasar sumarle a la variable <code>suma</code> \\(n^2\\), en notaci\u00f3n asint\u00f3tica esto se escribe como \\(\\mathcal{O}(n^2)\\).</p>"},{"location":"dia-1/complejidad/#ejemplo-3","title":"Ejemplo 3","text":"<p>\u00bfCu\u00e1nto se demora el siguiente programa?</p> <pre><code>int suma = 0;\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n        for (int k = 0; k &lt; n; k++) {\n            suma += k;\n        }\n    }\n}\n</code></pre>"},{"location":"dia-1/complejidad/#solucion-3","title":"Soluci\u00f3n 3","text":"<p>Haciendo el mismo an\u00e1lisis que en el ejemplo 2, la complejidad es \\(\\mathcal{O}(n^3)\\).</p>"},{"location":"dia-1/complejidad/#ideas-generales-de-la-complejidad","title":"Ideas generales de la complejidad","text":"<ul> <li>Hacer \\(k\\) veces una cosa que toma \\(T(n)\\) es \\(\\mathcal{O}(k \\cdot T(n))\\).</li> <li>Hacer un proceso que toma \\(T_1(n)\\) y despu\u00e9s otro que toma \\(T_2(n)\\) es \\(\\mathcal{O}(T_1(n) + T_2(n))\\). Pero si ambos son \\(T(n)\\) entonces el tiempo queda \\(T(2 n)\\) pero como \\(2\\) es una constante se convierte a \\(\\mathcal{O}(n)\\).</li> </ul> <p>Aclaraci\u00f3n importante, las constantes en la notaci\u00f3n asint\u00f3tica se pueden eliminar mientras que las variables se mantienen. Por eso en el ejemplo 2 se elimina el \\(2\\), mientras que en la idea general 1 no se elimina el \\(k\\).</p> <p>El calculo de la complejidad es algo general y puede ser que la constante si var\u00ede el tiempo de ejecuci\u00f3n. Esto es si queremos hilar m\u00e1s fino, pero en general los problemas est\u00e1n dise\u00f1ados para que no importe la constante.</p>"},{"location":"dia-1/complejidad/#ejemplo-mas-dificil","title":"Ejemplo m\u00e1s dif\u00edcil","text":"<pre><code>for i &lt;= n:\n    for i &lt;= j:\n        if A[i] + A[j] == 6:\n            print(\"Si\")\n</code></pre> <p>Con las reglas que hemos visto, la complejidad ser\u00eda de \\(\\mathcal{O}(n^2)\\).</p>"},{"location":"dia-1/complejidad/#como-saber-si-mi-codigo-pasa-dado-que-se-su-complejidad","title":"C\u00f3mo saber si mi c\u00f3digo pasa dado que se su complejidad","text":"<p>Como regla general se considera que un computador hace \\(10^8\\) operaciones por segundo (regla muy general pero sirve). Por lo que puede deducir que si un algoritmo tiene complejidad \\(\\mathcal{O}(n^2)\\) y \\(n = 10^3\\) entonces har\u00e1 \\(10^6\\) operaciones y como \\(10^6 &lt; 10^8\\) entonces el algoritmo se ejecutar\u00e1 en menos de un segundo.</p>    Tama\u00f1o input (\\(n\\)) Posibles complejidades     \\(n \\leq 10\\) \\(\\mathcal{O}(n !), \\mathcal{O}\\left(n^7\\right), \\mathcal{O}\\left(n^6\\right)\\)   \\(n \\leq 20\\) \\(\\mathcal{O}\\left(2^n \\cdot n\\right), \\mathcal{O}\\left(n^5\\right)\\)   \\(n \\leq 80\\) \\(\\mathcal{O}\\left(n^4\\right)\\)   \\(n \\leq 400\\) \\(\\mathcal{O}\\left(n^3\\right)\\)   \\(n \\leq 7500\\) \\(\\mathcal{O}\\left(n^2\\right)\\)   \\(n \\leq 7 \\cdot 10^4\\) \\(\\mathcal{O}(n \\sqrt{n})\\)   \\(n \\leq 5 \\cdot 10^5\\) \\(\\mathcal{O}(n \\log n)\\)   \\(n \\leq 5 \\cdot 10^6\\) \\(\\mathcal{O}(n)\\)   \\(n \\leq 10^{18}\\) \\(\\mathcal{O}\\left(\\log ^2 n\\right), \\mathcal{O}(\\log n), \\mathcal{O}(1)\\)"},{"location":"dia-1/complejidad/#ejemplo-con-insertion-sort","title":"Ejemplo con Insertion Sort","text":"<p>Insertion Sort es un algoritmo de ordenaci\u00f3n cuya idea principal es ir insertando el elemento en la posici\u00f3n correcta recorriendo de izquierda a derecha.</p>"},{"location":"dia-1/complejidad/#codigo-de-insertion-sort","title":"C\u00f3digo de Insertion Sort","text":"<p>El c\u00f3digo de Insertion Sort es el siguiente:</p> <pre><code>for (int i = 1; i &lt; n; i++) {\n    int j = i;\n    while (j &gt; 0 &amp;&amp; A[j] &lt; A[j - 1]) {\n        swap(A[j], A[j - 1]);\n        j--;\n    }\n}\n</code></pre> <p>La complejidad de este algoritmo es \\(\\mathcal{O}(n^2)\\).</p>"},{"location":"dia-1/complejidad/#ejemplo-con-merge-sort","title":"Ejemplo con Merge Sort","text":"<p>La idea de Merge Sort es dividir el array en dos partes y ordenar cada una de ellas por separado. Luego mezclar las dos partes ordenadas.</p> <p>Supongamos que tenemos los arrays <code>A = [1, 3, 7, 10]</code> y <code>B = [2, 5, 9]</code>. Dado que ambos est\u00e1n ordenados \u00bfC\u00f3mo ordenar\u00edas un array combinado de <code>A</code> con <code>B</code>?</p> <p>Podemos hacerlo con dos punteros, quedando: </p> <p><code>AB = [1, 2, 3, 5, 7, 9, 10]</code></p> <p>\u00bfCu\u00e1l es la complejidad de hacer esto? Es el largo de <code>A</code> m\u00e1s el largo de <code>B</code>. Supongamos que el largo de <code>A</code> es \\(n\\) y el de <code>B</code>, \\(m\\) entonces la complejidad ser\u00eda \\(\\mathcal{O}(n+m)\\).</p> <p>Ahora que sabemos c\u00f3mo juntar dos arrays ordenados podemos ocupar esto para ordenar un arreglo desordenado completamente.</p> <p>Vamos dividir a la mitad arreglo que deseamos ordenar. Luego cada mitad le aplicamos un algoritmo misterioso que los ordenar, y despu\u00e9s de que cada partici\u00f3n est\u00e1 ordenada podemos ocupar el algoritmo que ya conocemos para regresar el array completo ordenado.</p> <p>\u00bfCu\u00e1l es ese algoritmo misterioso? pues, el mismo (recursion).</p>  <p>En la base de esto estar\u00e1 ordenar el array de un solo elemento, como ya est\u00e1 ordenado (es solo un elemento) podemos retornar este arreglo unitario.</p> <p>Ahora veamos cual es su complejidad. Primero recordemos que la complejidad de unir dos arrays ordenados en otro ordenado (merge) es de \\(\\mathcal{O}(n)\\) con \\(n\\) el largo del array final. Pero cada nivel del merge toma \\(\\mathcal{O}(n)\\). \u00bfCu\u00e1ntos niveles van a haber en total? como en cada paso dividimos el arreglo en 2 va a ser hasta que queden arreglos de tama\u00f1o 1. Y esta cantidad sera aproximadamente \\(\\log_2(n)\\).</p> <p>Asi, el algoritmo de Merge Sort tiene complejidad \\(\\mathcal{O}(n \\cdot \\log_2(n))\\).</p> <p>Si no sabes que es un logaritmo ver ap\u00e9ndice.</p>"},{"location":"dia-1/complejidad/#codigo-de-merge-sort","title":"C\u00f3digo de Merge Sort","text":"<p>EL c\u00f3digo en <code>C++</code> ser\u00eda el siguiente:</p> <pre><code>void mergeSort(vector&lt;int&gt; &amp;A) {\n    if (A.size() == 1) {\n        return;\n    } else {\n        int mid = A.size() / 2;\n        vector&lt;int&gt; left(A.begin(), A.begin() + mid);\n        vector&lt;int&gt; right(A.begin() + mid, A.end());\n        mergeSort(left);\n        mergeSort(right);\n        merge(left, right, A);\n    }\n}\n\nvoid merge(vector&lt;int&gt; &amp;left, vector&lt;int&gt; &amp;right, vector&lt;int&gt; &amp;A) {\n    int i = 0, j = 0, k = 0;\n    while (i &lt; left.size() &amp;&amp; j &lt; right.size()) {\n        if (left[i] &lt; right[j]) {\n            A[k] = left[i];\n            i++;\n        } else {\n            A[k] = right[j];\n            j++;\n        }\n        k++;\n    }\n    while (i &lt; left.size()) {\n        A[k] = left[i];\n        i++;\n        k++;\n    }\n    while (j &lt; right.size()) {\n        A[k] = right[j];\n        j++;\n        k++;\n    }\n}\n</code></pre>"},{"location":"dia-1/complejidad/#las-operaciones-toman-tiempo-constante","title":"Las operaciones toman tiempo constante","text":"<p>Vamos a asumir que las operaciones de \\(c++\\) toman tiempo \\(\\mathcal{O}(1)\\), esto si nos ponemos muy detallistas no es tan cierto. Para los rangos de tipos de datos que trabajamos los procesadores trabajan muy bien con sus operaciones.</p>"},{"location":"dia-1/stl/","title":"Librer\u00eda Estandar de <code>C++</code> (STL)","text":"<p>Cuando ocupan vectores en <code>C++</code> ocupan la librer\u00eda est\u00e1ndar de <code>C++</code> (STL). Quiz\u00e1s para ocupar vectores ocupas a\u00f1adir la l\u00ednea <code>#include &lt;vector&gt;</code> al principio de tu c\u00f3digo. Podemos importar todas las herramientas que trae la librer\u00eda est\u00e1ndar de <code>C++</code> con <code>#include &lt;bits/stdc++.h&gt;</code>.</p> <p>Lo que nos interesa es aprovechar las estructuras que trae consigo la STL.</p>"},{"location":"dia-1/stl/#problema-del-pony","title":"Problema del pony","text":"<p>Se podia resolver metiendo todas las cartas en el arreglo, ordenando el arreglo y luego buscando la carta que quer\u00edamos.</p> <p>Pero podemos ocupar un <code>set</code> que es una estructura que viene en la STL.</p> <p><code>set&lt;int&gt; cartas;</code></p> <p>Lo que hace un <code>set</code> es insertar un elemento \\(x\\)</p> <p><code>cartas.insert(x);</code> \\(O(\\log(n))\\)</p> <p>Y tambi\u00e9n hacer preguntas del tipo: esta \\(y\\) en el <code>set</code>?</p> <p><code>cartas.count(y)</code> \\(O(\\log(n))\\)</p> <p>Y borrar un elemento \\(x\\) del <code>set</code>.</p> <p><code>cartas.erase(x)</code> \\(O(\\log(n))\\)</p> <p>Importante 1: el set no te permite elementos repetidos. Para tener elementos repetidos ocupas un <code>multiset</code>. Sin enmbargo (Marinkvich) no lo recomienda y es preferible usar mapas.</p> <p>Importante 2: Valores comparables. Para ocupar un set siempre tiene que haber un sentido de orden. Por eso se pueden hacer sets de <code>string</code> o <code>vectores</code>.</p> <p>Importante 3: No podemos acceder a una posicion del set por indice.</p>"},{"location":"dia-1/stl/#map","title":"Map","text":"<p>El <code>map</code> es el hijo del <code>vector</code> y el <code>set</code>. En un vector tenemos hartos valores y podemos acceder a ellos por su indice. En un set tenemos hartos valores y podemos preguntar si un valor esta en el set.</p> <p>En el mapa podemos tener hartos valores y podemos preguntar si un valor esta en el mapa y podemos acceder a ellos por su llave. Esta llave, a diferencia del vector que debe ser desde el \\(0\\), puede ser cualquier valor (hasheable) que queramos.</p> <p>Definimos el mapa</p> <p><code>map&lt;int, int&gt; mapa;</code></p> <p>Asociamos una llave \\(x\\) a un valor \\(y\\)</p> <p><code>mapa[1] = 2;</code></p> <p>Accedemos al valor asociado a la llave \\(x\\)</p> <p><code>mapa[1];</code></p>"},{"location":"dia-1/stl/#como-contar-cosas-con-un-mapa","title":"Como contar cosas con un mapa","text":"<p>Supongamos que tenemos un arreglo de \\(n\\) elementos y queremos saber cuantas veces esta cada elemento. Podemos tener un mapa <code>M</code> que te responda a <code>M[x]</code> cuantas veces esta el elemento <code>x</code>.</p> <p>El mapa tiene las mismas operaciones que el <code>set</code>. <code>M.count(x)</code> responde <code>0</code> no existe la llave <code>x</code> y <code>1</code> si existe la llave <code>x</code>.</p> <p>Todas sus operaciones son \\(O(\\log(n))\\).</p>"},{"location":"dia-1/stl/#las-posibilidades-estan-en-su-imaginacion","title":"Las posibilidades estan en su imaginacion","text":"<p>Podemos tener arreglos que accedamos por strings y que regresa un vector de enteros.</p>"},{"location":"dia-1/stl/#problema-del-pony-2","title":"Problema del pony 2","text":"<p>(resumen del problema inded)</p> <p>Ta cambio la carta \\(x\\) por la carta \\(y\\)?</p> <p>Podemos ocupar un mapa que cuenta las veces que se tiene cada carta.</p>"},{"location":"dia-1/stl/#queue","title":"<code>Queue</code>","text":"<p>Fila en ingles. Nos permite simular una fila. No podemos usar un <code>vector</code> para esto ya que este no nos permite sacar elementos del principio del arreglo.</p> <p><code>queue&lt;int&gt; fila;</code></p> <p>A;ade un elemento</p> <p><code>fila.push(x)</code> \\(O(1)\\)</p> <p>Elimina el elemento del principio</p> <p><code>fila.pop()</code> \\(O(1)\\)</p> <p>Accede al elemento del principio</p> <p><code>fila.front()</code> \\(O(1)\\)</p>"},{"location":"dia-1/stl/#problema-de-registro-ioi","title":"Problema de registro IOI","text":"<p>(resumen del problema inded)</p> <p>Resuelve este problema de manera directa. Ocupa una cola para simular la fila de personas.</p>"},{"location":"dia-1/stl/#stack","title":"<code>Stack</code>","text":"<p>Pila en ingles. Nos permite simular una pila. Donde lo que sacamos es el primer elemento y lo que a;adimos es al incio de la pila. Como una pila de platos.</p> <p><code>stack&lt;int&gt; pila;</code></p> <p>A;ade un elemento al inicio</p> <p><code>pila.push(x)</code> \\(O(1)\\)</p> <p>Elimina el elemento del principio</p> <p><code>pila.pop()</code> \\(O(1)\\)</p> <p>Accede al elemento del principio</p> <p><code>pila.top()</code> \\(O(1)\\)</p>"},{"location":"dia-1/stl/#deque","title":"<code>Deque</code>","text":"<p>Es una cola doble. Nos permite sacar y quitar elementos del principio y del final.</p> <p><code>deque&lt;int&gt; cola;</code></p> <p>A;ade un elemento al final</p> <p><code>cola.push_back(x)</code> \\(O(1)\\)</p> <p>A;ade un elemento al principio</p> <p><code>cola.push_front(x)</code> \\(O(1)\\)</p> <p>Elimina el elemento del final</p> <p><code>cola.pop_back()</code> \\(O(1)\\)</p> <p>Elimina el elemento del principio</p> <p><code>cola.pop_front()</code> \\(O(1)\\)</p> <p>Accede al elemento del final</p> <p><code>cola.back()</code> \\(O(1)\\)</p> <p>Accede al elemento del principio</p> <p><code>cola.front()</code> \\(O(1)\\)</p> <p>Nota: el <code>deque</code> pese a ser muy util muchas veces solo queremos ocupar la utilidad de una cola o una pila. Ademas que la <code>deque</code> es menos eficiente.</p>"},{"location":"dia-1/stl/#priority-queue","title":"<code>Priority Queue</code>","text":"<p>Es una cola de prioridad. Nos permite tener una cola la cual el primer elemento es siempre el valor mas grande. Por defecto esta ordenada de menor a mayor segun el comparador por defecto.</p> <p><code>priority_queue&lt;int&gt; cola;</code></p> <p>A;ade un elemento</p> <p><code>cola.push(x)</code> \\(O(\\log(n))\\)</p> <p>Elimina el elemento del principio</p> <p><code>cola.pop()</code> \\(O(\\log(n))\\)</p> <p>Accede al elemento del principio</p> <p><code>cola.top()</code> \\(O(1)\\)</p>"},{"location":"dia-1/stl/#comparar-de-menor-a-mayor","title":"Comparar de menor a mayor","text":"<p>Podemos ocupar un comparador personalizado para que la cola de prioridad ordene de mayor a menor.</p> <p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; cola;</code></p> <p>El <code>int</code> se puede cambiar por la clase/tipo de dato de la cola.</p>"},{"location":"dia-1/stl/#algoritmos-ya-implementados","title":"Algoritmos ya implementados","text":"<ul> <li> <p><code>sort</code>: ordena un vector. \\(O(n\\log(n))\\) Explicar mas a detalle.</p> </li> <li> <p><code>lower_bound</code>: le pasas un vector y un valor y te dice la posicion del primer elemento mayor o igual al valor. Si no existe te dice la posicion del primer elemento mayor al valor. Hace una busqueda binaria.</p> </li> <li> <p><code>upper_bound</code>: le pasas un vector y un valor y te dice la posicion del primer elemento mayor al valor. Si no existe te dice la posicion del primer elemento mayor al valor. Hace una busqueda binaria.</p> </li> <li> <p><code>find</code>: le pasas un vector y un valor y te dice la posicion del primer elemento igual al valor. Si no existe te dice la posicion del primer elemento mayor al valor. Hace una busqueda lineal.</p> </li> </ul>"}]}